/**
 * Generated by orval v6.10.2 üç∫
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */

// https://dataset.api.hub.geosphere.at/v1/openapi.json

export const API = "https://dataset.api.hub.geosphere.at/v1";

export const HISTORICAL_DATASETS = Object.freeze([
  "klima-v1-10min",
  "klima-v1-1d",
  "klima-v1-1h",
  "klima-v1-1m",
  "synop-v1-1h",
  "tawes-v1-10min",
]);

export interface ValidationError {
  loc: string[];
  msg: string;
  type: string;
}

export interface TimeseriesGeoJSONSerializer {
  media_type?: string;
  type?: string;
  version: string;
  /** Format: *YYYY-MM-DDThh:mm:ss¬±hh:mm* */
  timestamps: string[];
  features: GeoJSONFeature[];
}

export enum StationMetadataType {
  COMBINED = "COMBINED",
  SUB_STATION = "SUB_STATION",
  INDIVIDUAL = "INDIVIDUAL",
}

export interface StationMetadataDto {
  type: StationMetadataType;
  id: string;
  name: string;
  state?: string;
  lat?: number;
  lon?: number;
  altitude?: number;
  valid_from: string;
  valid_to: string;
  has_sunshine?: boolean;
  has_global_radiation?: boolean;
  /** List of sub-stations of this station. Only populated if type == COMBINED. */
  sub_stations?: StationMetadataDto[];
  matches?: boolean;
}

export interface StationMetadata {
  type: StationMetadataType;
  id: string;
  group_id?: string;
  name: string;
  state: string;
  lat: number;
  lon: number;
  altitude?: number;
  valid_from: string;
  valid_to: string;
  has_sunshine?: boolean;
  has_global_radiation?: boolean;
}

export interface StationGeoJSONSerializer {
  media_type?: string;
  type?: string;
  version: string;
  /** Format: *YYYY-MM-DDThh:mm:ss¬±hh:mm* */
  timestamps: string[];
  features: StationGeoJSONFeature[];
}

type StationGeoJSONPropertiesParameters = {
  [key: string]: GeoJSONFeatureParameter;
};

export interface StationGeoJSONProperties {
  parameters: StationGeoJSONPropertiesParameters;
  station: string;
}

export interface StationFilterResponseDto {
  num_stations_total: number;
  num_stations_matching: number;
  matching_stations: StationMetadataDto[];
}

export interface StationCSVSerializer {
  media_type?: string;
  content: string;
  filename: string;
}

export interface ParameterMetadataModel {
  name: string;
  long_name: string;
  desc: string;
  unit: string;
}

export interface StationHistoricalMetadataModel {
  title: string;
  parameters: ParameterMetadataModel[];
  frequency: string;
  type: string;
  mode: string;
  response_formats: string[];
  start_time: string;
  end_time: string;
  stations: StationMetadata[];
}

export interface StationCurrentMetadataModel {
  title: string;
  parameters: ParameterMetadataModel[];
  frequency: string;
  type: string;
  mode: string;
  response_formats: string[];
  time: string;
  stations: StationMetadata[];
}

export enum OutputFormat {
  geojson = "geojson",
  netcdf = "netcdf",
  csv = "csv",
}

export enum MDType {
  stations = "stations",
  parameters = "parameters",
}

export interface GridHistoricalMetadataModel {
  title: string;
  parameters: ParameterMetadataModel[];
  frequency: string;
  type: string;
  mode: string;
  response_formats: string[];
  start_time: string;
  end_time: string;
  bbox: number[];
  spatial_resolution_m: number;
}

export interface GridCurrentMetadataModel {
  title: string;
  parameters: ParameterMetadataModel[];
  frequency: string;
  type: string;
  mode: string;
  response_formats: string[];
  time: string;
  bbox: number[];
  spatial_resolution_m: number;
}

export interface GeoJSONPoint {
  type?: string;
  /** Point coordinates are in x, y order (easting, northing for projected coordinates, longitude, and latitude for geographic coordinates) */
  coordinates: number[];
}

export interface StationGeoJSONFeature {
  type?: string;
  geometry: GeoJSONPoint;
  properties: StationGeoJSONProperties;
}

export interface GeoJSONFeatureParameter {
  name: string;
  unit: string;
  data: number[];
}

type GeoJSONFeaturePropertiesParameters = {
  [key: string]: GeoJSONFeatureParameter;
};

export interface GeoJSONFeatureProperties {
  parameters: GeoJSONFeaturePropertiesParameters;
}

export interface GeoJSONFeature {
  type?: string;
  geometry: GeoJSONPoint;
  properties: GeoJSONFeatureProperties;
}

export interface GridGeoJSONSerializer {
  media_type?: string;
  type?: string;
  version: string;
  /** Format: *YYYY-MM-DDThh:mm:ss¬±hh:mm* */
  timestamps: string[];
  features: GeoJSONFeature[];
  bbox: number[];
}

export enum EndpointType {
  grid = "grid",
  timeseries = "timeseries",
  station = "station",
}

export enum EndpointMode {
  historical = "historical",
  current = "current",
  forecast = "forecast",
  "forecast-multiple" = "forecast-multiple",
}

export interface Dataset {
  type: EndpointType;
  mode: EndpointMode;
  response_formats: OutputFormat[];
}
